// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "stdafx.h"
#include "GameFuncCall.h"
#include <atlstr.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <thrift/transport/TPipeServer.h>

#include <thrift/TProcessor.h>
#include <thrift/Server/TThreadPoolServer.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include "FuncCore.h"
#include <map>
#include <set>
#include <sstream>
#include <fstream>
#include <iostream>
#include <string>
using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::thrift::GameCall;
int DrawMap(unsigned char* p, DWORD x, DWORD y,DWORD halfX);
wchar_t MonsterType[] = L"Metadata/Monsters";//17
wchar_t TrophyType[] = L"Metadata/MiscellaneousObjects/WorldItem";
wchar_t DoorType[] = L"Metadata/MiscellaneousObjects/Door";
wchar_t DoorType2[] = L"Metadata/MiscellaneousObjects/Lights/ScepterDoorLight";
wchar_t DoorType3[] = L"Metadata/MiscellaneousObjects/Lights/IncaDoorLight";
wchar_t BoxType[] = L"Metadata/Chests";//宝箱
wchar_t WaypointType[] = L"Metadata/MiscellaneousObjects/Waypoint";//传送点
wchar_t StorageType[] = L"Metadata/MiscellaneousObjects/Stash";//仓库
wchar_t DoodadType[] = L"Metadata/MiscellaneousObjects/Doodad";

wchar_t NPCType[] = L"Metadata/NPC/";
wchar_t GobattleTransferDoorType[] = L"Metadata/MiscellaneousObjects/TownPortal";
wchar_t GobackTransferDoorType[] = L"Metadata/MiscellaneousObjects/PlayerPortal";
wchar_t CrossAreaType[] = L"Metadata/MiscellaneousObjects/AreaTransition";

wchar_t ShrineType[] = L"Metadata/Shrines";//神殿

extern TCHAR szModulePath[MAX_PATH];

__inline bool IsMonster(BYTE* pInterfaceName)
{
	if (memcmp(MonsterType, pInterfaceName, sizeof(MonsterType)-2) == 0)
		return true;
	return false;
}
__inline bool IsTrophy(BYTE* pInterfaceName)
{
	if (memcmp(TrophyType, pInterfaceName, sizeof(TrophyType)-2) == 0)
		return true;
	return false;
}
__inline bool IsDoor(BYTE* pInterfaceName)
{
	if (memcmp(DoorType, pInterfaceName, sizeof(DoorType)-2) == 0)
		return true;
	if (memcmp(DoorType2, pInterfaceName, sizeof(DoorType2)-2) == 0)
		return true;
	if (memcmp(DoorType3, pInterfaceName, sizeof(DoorType3)-2) == 0)
		return true;
	return false;
}
__inline bool IsBox(BYTE* pInterfaceName)
{
	if (memcmp(BoxType, pInterfaceName, sizeof(BoxType)-2) == 0)
		return true;
	return false;
}
__inline bool IsWaypoint(BYTE* pInterfaceName)
{
	if (memcmp(WaypointType, pInterfaceName, sizeof(WaypointType)-2) == 0)
		return true;
	return false;
}
__inline bool IsDoodad(BYTE* pInterfaceName)
{
	if (memcmp(DoodadType, pInterfaceName, sizeof(DoodadType)-2) == 0)
		return true;
	return false;
}
__inline bool IsNPC(BYTE* pInterfaceName)
{
	if (memcmp(NPCType, pInterfaceName, sizeof(NPCType)-2) == 0)
		return true;
	return false;
}
__inline bool IsGobattleTransferDoor(BYTE* pInterfaceName)
{
	if (memcmp(GobattleTransferDoorType, pInterfaceName, sizeof(GobattleTransferDoorType)-2) == 0)
		return true;
	return false;
}
__inline bool IsGobackTransferDoor(BYTE* pInterfaceName)
{
	if (memcmp(GobackTransferDoorType, pInterfaceName, sizeof(GobackTransferDoorType)-2) == 0)
		return true;
	return false;
}
__inline bool IsStorage(BYTE* pInterfaceName)
{
	if (memcmp(StorageType, pInterfaceName, sizeof(StorageType)-2) == 0)
		return true;
	return false;
}
__inline bool IsCrossArea(BYTE* pInterfaceName)
{
	if (memcmp(CrossAreaType, pInterfaceName, sizeof(CrossAreaType)-2) == 0)
		return true;
	return false;
}
__inline bool IsShrine(BYTE* pInterfaceName)
{
	if (memcmp(ShrineType, pInterfaceName, sizeof(ShrineType)-2) == 0)
		return true;
	return false;
}

const char UnknowType = 0;
const char byMonsterType = 1;
const char byChestType = 2;
const char byDoorType = 3;
const char byTrophyType = 4;
const char byWaypointType = 5;//传送门
const char byStorageType = 6;//仓库
const char byCrossAreaDoor = 7;//d地图连接门
const char byShrineType = 8;//神殿
const char byPollutantDoor = 9;//遗落地窖门
/////////////////////////////////
//宝石,血瓶,技能石,装备,戒指,项链
wchar_t SkillStoneType[] = L"Metadata/Items/Gems";//技能石  SkillGem
wchar_t CurrencyType[] = L"Metadata/Items/Currency/Currency";//卷轴,宝石
wchar_t FlaskType[] = L"Metadata/Items/Flasks/Flask";//血瓶
wchar_t ArmourType[] = L"Metadata/Items/Armours/";//装备
wchar_t RingType[] = L"Metadata/Items/Rings/Ring";//戒指
wchar_t AmuletType[] = L"Metadata/Items/Amulets/Amulet";//项链
wchar_t WeaponType[] = L"Metadata/Items/Weapons";//武器
wchar_t QuiverType[] = L"Metadata/Items/Quivers";//弓箭包
wchar_t QuestItemType[] = L"Metadata/Items/QuestItems";//任务物品
wchar_t BeltType[] = L"Metadata/Items/Belts";//腰带
wchar_t MapsType[] = L"Metadata/Items/Map";//地图

__inline bool IsSkillStoneType(BYTE* pInterfaceName)
{
	if (memcmp(SkillStoneType, pInterfaceName, sizeof(SkillStoneType)-2) == 0)
		return true;
	return false;
}
__inline bool IsArmourType(BYTE* pInterfaceName)
{
	if (memcmp(ArmourType, pInterfaceName, sizeof(ArmourType)-2) == 0)
		return true;
	return false;
}
__inline bool IsCurrencyType(BYTE* pInterfaceName)
{
	if (memcmp(CurrencyType, pInterfaceName, sizeof(CurrencyType)-2) == 0)
		return true;
	return false;
}
__inline bool IsFlaskType(BYTE* pInterfaceName)
{
	if (memcmp(FlaskType, pInterfaceName, sizeof(FlaskType)-2) == 0)
		return true;
	return false;
}
__inline bool IsRingType(BYTE* pInterfaceName)
{
	if (memcmp(RingType, pInterfaceName, sizeof(RingType)-2) == 0)
		return true;
	return false;
}
__inline bool IsAmuletType(BYTE* pInterfaceName)
{
	if (memcmp(AmuletType, pInterfaceName, sizeof(AmuletType)-2) == 0)
		return true;
	return false;
}
__inline bool IsWeaponType(BYTE* pInterfaceName)
{
	if (memcmp(WeaponType, pInterfaceName, sizeof(WeaponType)-2) == 0)
		return true;
	return false;
}
__inline bool IsQuestItemType(BYTE* pInterfaceName)
{
	if (memcmp(QuestItemType, pInterfaceName, sizeof(QuestItemType)-2) == 0)
		return true;
	return false;
}
__inline bool IsBeltType(BYTE* pInterfaceName)
{
	if (memcmp(BeltType, pInterfaceName, sizeof(BeltType)-2) == 0)
		return true;
	return false;
}
__inline bool IsQuiverType(BYTE* pInterfaceName)
{
	if (memcmp(QuiverType, pInterfaceName, sizeof(QuiverType)-2) == 0)
		return true;
	return false;
}
__inline bool IsMapsType(BYTE* pInterfaceName)
{
	if (memcmp(MapsType, pInterfaceName, sizeof(MapsType)-2) == 0)
		return true;
	return false;
}

const char byTrophy_SkillStone = 1;//技能石
const char byTrophy_Currency = 2;//卷轴宝石
const char byTrophy_Flask = 3;//血瓶
const char byTrophy_Armour = 4;//装备
const char byTrophy_Ring = 5;//戒指
const char byTrophy_Amulet = 6;//项链
const char byTrophy_Belt =7;//腰带
const char byTrophy_Weapon = 8;//武器
const char byTrophy_Quiver = 9;//箭包
const char byTrophy_QuestItem = 10;//任务物品
const char byTrophy_Maps = 11;//地图
const char byTrophy_Money = 12;//通货

extern void MYTrancport(ULONG MapID, ULONG WaypointID);

wchar_t TransDoorType[] = L"魉途磔S";
__inline bool IsTransDoorType(BYTE* pName)
{
	if (memcmp(TransDoorType, pName, sizeof(TransDoorType)-2) == 0)
		return true;
	return false;
}

class GameFuncCallHandler : virtual public GameFuncCallIf 
{
public:
	map<wstring, int> NPCList;
	GameFuncCallHandler() 
	{
		// Your initialization goes here
		wstring strTargetNPCName;

		strTargetNPCName = L"奈莎";
		NPCList.insert(std::make_pair(strTargetNPCName, 1));

		strTargetNPCName = L"古斯特";
		NPCList.insert(std::make_pair(strTargetNPCName, 2));
		//case 3:
		strTargetNPCName = L"R根";
		NPCList.insert(std::make_pair(strTargetNPCName, 3));
		//	case 4:
		strTargetNPCName = L"o甲大哈";
		NPCList.insert(std::make_pair(strTargetNPCName, 4));
		//	case 5:
		strTargetNPCName = L"亡`大卡塔莉娜";
		NPCList.insert(std::make_pair(strTargetNPCName, 5));
		//	case 6:
		strTargetNPCName = L"武器大瓦甘";
		NPCList.insert(std::make_pair(strTargetNPCName, 6));
		//	case 7:
		strTargetNPCName = L"刺⒋瓦里西";
		NPCList.insert(std::make_pair(strTargetNPCName, 7));
		//	case 8:
		strTargetNPCName = L"博W大艾雷恩";
		NPCList.insert(std::make_pair(strTargetNPCName, 8));
		//	case 9:
		strTargetNPCName = L"狩C大托";
		NPCList.insert(std::make_pair(strTargetNPCName, 9));
		//case 10:
		strTargetNPCName = L"uD大札娜";
		NPCList.insert(std::make_pair(strTargetNPCName, 10));

	}

	int32_t SetUID(const std::string& strUID, const std::string& strPWD) 
	{
		// Your implementation goes here
		printf("SetUID\n");
		return 0;
	}

	bool IsValidServer()
	{
		// Your implementation goes here
	//	printf("IsValidServer\n");
		if (hGameWnd == NULL)
		{
			hGameWnd = ::FindWindow(L"Direct3DWindowClass", NULL);
			if (hGameWnd == NULL)
			{
				MessageBox(NULL, L"窗口未初始化,无法发送按键消息", NULL, MB_OK);
				return 0;
			}
		}


		PostMessage(hGameWnd, WM_KEYDOWN, 0x35, 0x60001);
		PostMessage(hGameWnd, WM_CHAR, 0x35, 0x60001);
		PostMessage(hGameWnd, WM_KEYUP, 0x35, 0xC0060001);

		return 0;
	}

	void Test() 
	{
		// Your implementation goes here
		SendMessage(hGameWnd, WM_LG_CALL, F_GetPlayerInfo, NULL);
		CString strInfo;
		strInfo.Format(L"ggggggHP:%d,LEVEL:%d,name:%s",
			_PlayerInfo.HP, 
			_PlayerInfo.Level,
			_PlayerInfo.Name);
	//	ReadSelfInfo
		OutputDebugString(strInfo);
		printf("Test\n");
	}

	void Update() 
	{
		// Your implementation goes here
	//	printf("Update\n");
		DWORD x, y, z;
		//Y应该是X2倍
		unsigned char * pp=ReadMapData(&x,&y,&z);
		DrawMap(pp, y, z,x);
	}

	void SetWorkPath(const std::string& strPath)
	{
		MessageBoxA(NULL, strPath.c_str(), NULL, MB_OK);
		// Your implementation goes here
	//	printf("SetWorkPath\n");
	}

	void GetPlayerPos(Pos& _return) 
	{

#ifndef NO_DEBUG
			::OutputDebugString(L"GetPlayerPos\n");
#endif
		// Your implementation goes here
		//printf("GetPlayerPos\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_GetPlayerPos, NULL);
		_return.x = PlayerPos.x;
		_return.y = PlayerPos.y;
	}

	void Move(const int32_t x, const int32_t y) 
	{
		// Your implementation goes here
		MoveInfo.x = x;
		MoveInfo.y = y;
		SendMessage(hGameWnd, WM_LG_CALL, F_MOVE, NULL);
		//printf("Move\n");
	}

	void CastUntargetSkill(const int16_t x, const int16_t y, const int16_t skillNum, const int16_t castType)
	{
		// Your implementation goes here
		untargetSkill.x = x;
		untargetSkill.y = y;
		untargetSkill.num = skillNum;
		untargetSkill.type = castType;
		SendMessage(hGameWnd, WM_LG_CALL, F_CastUntargetSkill, NULL);
		//printf("CastUntargetSkill\n");
	}
	void CastTargetSkill(const int32_t TargetObjPtr, const int16_t skillNum, const int16_t castType) 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"CastTargetSkill\n");
#endif
		// Your implementation goes here
		SkillTargetObjPtr = TargetObjPtr;
		SkillNum = skillNum;
		SkillModel = castType;
		SendMessage(hGameWnd, WM_LG_CALL, F_CastTargetSkill, NULL);
	}
	std::set<Point> TrophyFilter;
	std::set<wstring> PollutantGateName;
	std::map<wstring,int> PriorMonsterName;
	void GetRoundList(std::vector<ObjInfo> & _return)
	{
		// Your implementation goes here
#ifndef NO_DEBUG
		::OutputDebugString(L"GetRoundList\n");
#endif
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
			int nPrior = 0;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsMonster(pTempRoundList->InterfaceName))
				{
					if (pTempRoundList->TargetAble == 0 )
					{
						++pTempRoundList;
						continue;
					}
					if (pTempRoundList->Unknow == 129)
					{
						++pTempRoundList;
						continue;
					}
					if (pTempRoundList->TargetAble == 1 && pTempRoundList->Unknow == 0)
					{
						if (pTempRoundList->IsNPC == 1 && pTempRoundList->IsNPCAttackAble!=0)
						{
							++pTempRoundList;
							continue;
						}
					}
					type = byMonsterType;

					if (pTempRoundList->HP > 0)
					{
						wstring strName = (wchar_t*)pTempRoundList->Name;
						auto iter = PriorMonsterName.find(strName);
						if (iter != PriorMonsterName.end())
						{
							nPrior = iter->second;
						}
						int nPos = strName.find(L"Dv");
						if (nPos >= 0)
						{
							nPrior |= 128;
						}
					}
				}
				else if (IsBox(pTempRoundList->InterfaceName))
				{
				//	if (pTempRoundList->TargetAble == 1 && pTempRoundList->Unknow == 0)
					if (pTempRoundList->TargetAble == 1)
						type = byChestType;
					else
					{
						++pTempRoundList;
						continue;
					}
				}
				else if (IsTrophy(pTempRoundList->InterfaceName))
				{
					Point pos(pTempRoundList->X2, pTempRoundList->Y2);
					auto iter=TrophyFilter.find(pos);
					if (iter != TrophyFilter.end())
					{
						++pTempRoundList;
						continue;
					}
					type = byTrophyType;
				}
				else if (IsDoor(pTempRoundList->InterfaceName))
				{
					//if (pTempRoundList->TargetAble == 1 && pTempRoundList->Unknow == 0)
					if (pTempRoundList->TargetAble == 1)
						type = byDoorType;
					else 
					{
						++pTempRoundList;
						continue;
					}
				}
				else if (IsWaypoint(pTempRoundList->InterfaceName))
				{
					type = byWaypointType;
				}
				else if (IsShrine(pTempRoundList->InterfaceName))
				{
					//type = byShrineType;
					//当成门处理
					if (pTempRoundList->TargetAble == 1)
						type = byDoorType;
					else
					{
						++pTempRoundList;
						continue;
					}
				}
				else if (IsCrossArea(pTempRoundList->InterfaceName))
				{
					wstring strName = (wchar_t*)pTempRoundList->Name;
					auto iter=PollutantGateName.find(strName);
					//L"z落地窖"
					if (strName == L"翘")
					{
						type = byCrossAreaDoor;
					}
					else if (iter != PollutantGateName.end())
					{
						type = byPollutantDoor;
					}
					else 
					{
						++pTempRoundList;
						continue;
					}
				}
				else
				{
					++pTempRoundList;
					continue;
				}
			}
		/*	if (IsDoodad(pTempRoundList->InterfaceName))
			{
				++pTempRoundList;
				continue;
			}*/
		//	type = 1;
			ObjInfo temp;
			temp.Type = type;
			temp.ObjPtr = (int)pTempRoundList->mem2;
			temp.EnemyID = pTempRoundList->EnemyID;
			temp.HP = pTempRoundList->HP;
			temp.ID = pTempRoundList->ID;
			temp.Level = pTempRoundList->Level;
			temp.MaxHP = pTempRoundList->MaxHP;
			temp.X = pTempRoundList->X2;
			temp.Y = pTempRoundList->Y2;
			temp.Color=pTempRoundList->Color;
			temp.Color |= nPrior;
#ifndef NO_DEBUG
			for (int j = 0; j < 64; j += 2)
			{
				if (pTempRoundList->Name[j] == 0 && pTempRoundList->Name[j] == 0)
					break;
				temp.Name.push_back(pTempRoundList->Name[j]);
				temp.Name.push_back(pTempRoundList->Name[j+1]);
			}
			for (int j = 0; j < 192; j += 2)
			{
				if (pTempRoundList->InterfaceName[j] == 0 && pTempRoundList->InterfaceName[j] == 0)
					break;
				temp.TypeName.push_back(pTempRoundList->InterfaceName[j]);
				temp.TypeName.push_back(pTempRoundList->InterfaceName[j + 1]);
			}
#endif
			_return.push_back(temp);
			++pTempRoundList;
		}
	//	printf("GetRoundList\n");
	}
	void GetRoundListTest(std::vector<ObjInfo> & _return) 
	{
//#ifndef NO_DEBUG
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
		
			/*	if (IsDoodad(pTempRoundList->InterfaceName))
			{
			++pTempRoundList;
			continue;
			}*/
			type = 0;
			ObjInfo temp;
			temp.Type = type;
			temp.ObjPtr = (int)pTempRoundList->mem2;
			temp.EnemyID = pTempRoundList->EnemyID;
			temp.HP = pTempRoundList->HP;
			temp.ID = pTempRoundList->ID;
			/*temp.Level = pTempRoundList->Level;
			temp.MaxHP = pTempRoundList->MaxHP;*/

			temp.Level = pTempRoundList->TargetAble;
			temp.MaxHP = pTempRoundList->Unknow;

			temp.X = pTempRoundList->X2;
			temp.Y = pTempRoundList->Y2;
			temp.Color = pTempRoundList->Color;

			for (int j = 0; j < 64; j += 2)
			{
				if (pTempRoundList->Name[j] == 0 && pTempRoundList->Name[j] == 0)
					break;
				temp.Name.push_back(pTempRoundList->Name[j]);
				temp.Name.push_back(pTempRoundList->Name[j + 1]);
			}
			for (int j = 0; j < 192; j += 2)
			{
				if (pTempRoundList->InterfaceName[j] == 0 && pTempRoundList->InterfaceName[j] == 0)
					break;
				temp.TypeName.push_back(pTempRoundList->InterfaceName[j]);
				temp.TypeName.push_back(pTempRoundList->InterfaceName[j + 1]);
			}
			//memcpy(temp.Name, pTempRoundList->Name, 64);

			_return.push_back(temp);
			++pTempRoundList;
		}
//#endif
	}
	void GetPlayerInfo(PlayerInfo& _return)
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetPlayerInfo\n");
#endif
		// Your implementation goes here
	//	printf("GetPlayerInfo\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_GetPlayerInfo, NULL);

		//_return.ObjPtr = (int)_PlayerInfo.mem2;
		//_return.EnemyID = _PlayerInfo.EnemyID;
		//_return.ID = _PlayerInfo.ID;
		_return.Level = _PlayerInfo.Level;
		_return.HP = _PlayerInfo.HP;
		_return.MaxHP = _PlayerInfo.MaxHP;
		_return.MP = _PlayerInfo.MP;
		_return.MaxMP = _PlayerInfo.MaxMP;
		_return.Shield = _PlayerInfo.Shield;
		_return.X = _PlayerInfo.X2;
		_return.Y = _PlayerInfo.Y2;
		/*for (int j = 0; j < 64; j += 2)
		{
			if (_PlayerInfo.Name[j] == 0 && _PlayerInfo.Name[j] == 0)
				break;
			_return.Name.push_back(_PlayerInfo.Name[j]);
			_return.Name.push_back(_PlayerInfo.Name[j + 1]);
		}*/
		/*for (int j = 0; j < 192; j += 2)
		{
			if (PlayerInfo.InterfaceName[j] == 0 && PlayerInfo.InterfaceName[j] == 0)
				break;
			_return.TypeName.push_back(PlayerInfo.InterfaceName[j]);
			_return.TypeName.push_back(PlayerInfo.InterfaceName[j + 1]);
		}*/
	}
	void StopMove() 
	{
		SendMessage(hGameWnd, WM_LG_CALL, F_StopMove, NULL);
		// Your implementation goes here
	//	printf("StopMove\n");
	}
	void GetMapData(MapInfo& _return) 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetMapData\n");
#endif
		// Your implementation goes here
		//
		//SendMessage(hGameWnd, WM_LG_CALL, F_GetMapData, NULL);
		DWORD halfX, X, Y;
		//Y应该是X2倍
		char * pp =(char*) ReadMapData(&halfX, &X, &Y);
		_return.X = X;
		_return.HalfX = halfX;
		_return.Y = Y;
		for (int i = 0; i < Y; ++i)
		{
			for (int j = 0; j < halfX; ++j)
				_return.MapData.push_back(*(pp + halfX*i + j));
		}
		//DrawMap(pp, y, z, x);
		//printf("GetMapData\n");
	}

	void ActiveTarget(const int32_t ObjPtr) 
	{
		// Your implementation goes here
		ActiveObjPtr = ObjPtr;
		SendMessage(hGameWnd, WM_LG_CALL, F_ActiveTarget, NULL);
	//	printf("ActiveTarget\n");
	}

	void GetWaypointInfo(std::vector<WaypointInfo> & _return) 
	{
		// Your implementation goes here
		//printf("GetWaypointInfo\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_GetWaypointInfo, NULL);
		Waypoint* pTemp=pWaypointList;
		for (int i = 0; i < 300; ++i)
		{
			if (pTemp->Mem == 0)
			{
				++pTemp;
				continue;
			}
			WaypointInfo temp;
			temp.ID = pTemp->ID;
			temp.Mem = pTemp->Mem;

			for (int j = 0; j < 32; j += 2)
			{
				if (pTemp->Name[j] == 0 && pTemp->Name[j + 1] == 0)
					break;
				temp.Name.push_back(pTemp->Name[j]);
				temp.Name.push_back(pTemp->Name[j + 1]);
			}
			for (int j = 0; j < 32; j += 2)
			{
				if (pTemp->ActName[j] == 0 && pTemp->ActName[j + 1] == 0)
					break;
				temp.ActName.push_back(pTemp->ActName[j]);
				temp.ActName.push_back(pTemp->ActName[j + 1]);
			}
			_return.push_back(temp);
			++pTemp;
		}
		
	}
	void Transport(const int32_t MapID, const int32_t WaypointID, const int32_t DungeonModel)
	//void Transport(const int32_t MapID, const int32_t WaypointID) 
	{
		//CallTransport(MapID, WaypointID);
	//	MYTrancport(MapID, WaypointID);
		TransMapID = MapID;
		TransWaypointID = WaypointID;
		nDungeonModel = DungeonModel;
		SendMessage(hGameWnd, WM_LG_CALL, F_Transport, NULL);

		if (DungeonModel==1)
		{
			::Sleep(1000);
			SendMessage(hGameWnd, WM_LG_CALL, F_CreateNewDungeon, NULL);
		}
		// Your implementation goes here
		//printf("Transport\n");
	}
	void GetBagItemSpaceInfo(std::vector<ItemSpaceInfo> & _return) 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetBagItemSpaceInfo\n");
#endif
		ContainerType = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			ItemSpaceInfo temp;
			temp.Height = pBag->Items[i].Height;
			temp.Width = pBag->Items[i].Width;
			temp.Left = pBag->Items[i].Left;
			temp.Top = pBag->Items[i].Top;
			_return.push_back(temp);
		}
	}
	void GetContainerItemList(std::vector<ItemInfo> & _return, const int32_t GetType)
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetContainerItemList\n");
#endif
		// Your implementation goes here
		ContainerType = GetType;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			ItemInfo temp;
			temp.WinID = pBag->WinID;
			temp.BagObjPtr = pBag->Mem;////////////这里要注意
			temp.ObjPtr = pBag->Items[i].ObjPtr;
			temp.ID = pBag->Items[i].ID;
			temp.Color = pBag->Items[i].Color;
			temp.Count = pBag->Items[i].Count;
			temp.MaxCount = pBag->Items[i].MaxCount;
			temp.ServiceID = pBag->Items[i].ServiceID;
			temp.Left = pBag->Items[i].Left;
			temp.Top = pBag->Items[i].Top;
			temp.Width = pBag->Items[i].Width;
			temp.Height = pBag->Items[i].Height;
			if (pBag->Items[i].IsEquipment == 1 && pBag->Items[i].IsIdentity == 0)
				temp.NeedIdentify = true;
			else
				temp.NeedIdentify = false;

			temp.SocketConnect = 0;
			temp.Socket = 0;
			int begin = 0;
			for (int d = 0; d<6; ++d)
			{
				if (pBag->Items[i].SocketsContact[d] == 0)
					break;
				if (pBag->Items[i].SocketsContact[d]>temp.SocketConnect)
				{
					temp.SocketConnect = pBag->Items[i].SocketsContact[d];
				}
				if (pBag->Items[i].SocketsContact[d] > 2)//检测三色孔
				{
					int SocketColor = 0;
					for (int j = begin; j <( pBag->Items[i].SocketsContact[d]+begin); ++j)
					{
						switch (pBag->Items[i].Sockets[j])
						{
						case 1:
							SocketColor |= 1;
							break;
						case 2:
							SocketColor |= 2;
							break;
						case 3:
							SocketColor |= 4;
							break;
						}
					}
					if (SocketColor == 7)
						temp.ThreeColorSocket = true;
				}
				begin += pBag->Items[i].SocketsContact[d];
			}
			for (int j = 0; j < 6; ++j)
			{
				switch (pBag->Items[i].Sockets[j])
				{
				case 1:
				case 2:
				case 3:
					++(temp.Socket);
					break;
				}
			}
			
			if (IsSkillStoneType(pBag->Items[i].InterfaceName))//1
			{
				temp.Type = byTrophy_SkillStone;
			}
			else if (IsCurrencyType(pBag->Items[i].InterfaceName))//2
			{
				CStringW strName = (wchar_t*)(pBag->Items[i].Name);
				if (strName == L"魉途磔S" || strName == L"知R卷S")
				{
					temp.Type = byTrophy_Currency;
				}
				else
					temp.Type = byTrophy_Money;
			}
			else if (IsFlaskType(pBag->Items[i].InterfaceName))//3
			{
				temp.Type = byTrophy_Flask;
			}
			else if (IsArmourType(pBag->Items[i].InterfaceName))//4
			{
				temp.Type = byTrophy_Armour;
			}
			else if (IsRingType(pBag->Items[i].InterfaceName))//5
			{
				temp.Type = byTrophy_Ring;
			}
			else if (IsAmuletType(pBag->Items[i].InterfaceName))//6
			{
				temp.Type = byTrophy_Amulet;
			}
			else if (IsWeaponType(pBag->Items[i].InterfaceName))//7
			{
				temp.Type = byTrophy_Weapon;
			}
			else if (IsQuestItemType(pBag->Items[i].InterfaceName))//8
			{
				temp.Type = byTrophy_QuestItem;
			}
			else if (IsBeltType(pBag->Items[i].InterfaceName))//9
			{
				temp.Type = byTrophy_Belt;
			}
			else if (IsQuiverType(pBag->Items[i].InterfaceName))//10
			{
				temp.Type = byTrophy_Weapon;//箭包暂时算武器
			}
			else if (IsMapsType(pBag->Items[i].InterfaceName))
			{
				temp.Type = byTrophy_Maps;//地图
			}
			else
				temp.Type = UnknowType;

			for (int j = 0; j < 64; j += 2)
			{
				if (pBag->Items[i].Name[j] == 0 && pBag->Items[i].Name[j + 1] == 0)
					break;
				temp.Name.push_back(pBag->Items[i].Name[j]);
				temp.Name.push_back(pBag->Items[i].Name[j + 1]);
			}
#ifndef NO_DEBUG
			for (int j = 0; j < 192; j += 2)
			{
				if (pBag->Items[i].InterfaceName[j] == 0 && pBag->Items[i].InterfaceName[j + 1] == 0)
					break;
				temp.TypeName.push_back(pBag->Items[i].InterfaceName[j]);
				temp.TypeName.push_back(pBag->Items[i].InterfaceName[j + 1]);
			}
#endif		
			_return.push_back(temp);
		}

	}

	void GetCurrentMapInfo(WaypointInfo& _return) 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetCurrentMapInfo\n");
#endif
		//printf("GetCurrentMapID\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_GetMapID, NULL);
		_return.Mem = CurMapInfo.Mem;
		_return.ID = CurMapInfo.ID;
		for (int j = 0; j < 32; j += 2)
		{
			if (CurMapInfo.Name[j] == 0 && CurMapInfo.Name[j + 1] == 0)
				break;
			_return.Name.push_back(CurMapInfo.Name[j]);
			_return.Name.push_back(CurMapInfo.Name[j + 1]);
		}
		for (int j = 0; j < 32; j += 2)
		{
			if (CurMapInfo.ActName[j] == 0 && CurMapInfo.ActName[j + 1] == 0)
				break;
			_return.ActName.push_back(CurMapInfo.ActName[j]);
			_return.ActName.push_back(CurMapInfo.ActName[j + 1]);
		}
	}

	int32_t GetCurrentMapID() 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetCurrentMapID\n");
#endif
		SendMessage(hGameWnd, WM_LG_CALL, F_GetMapID, NULL);
		return  CurMapInfo.ID;
	}

	void GetTrophyInfo(TrophyInfo& _return, const int32_t TrophyObjPtr) 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetTrophyInfo\n");
#endif
		NolootTrophyObjPtr = TrophyObjPtr;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetTrophyInfo, NULL);
		_return.ObjPtr = TrophyObjPtr;
		_return.Color = _TrophyInfo.Color;
		_return.ID = _TrophyInfo.ID;
		_return.Width = _TrophyInfo.Width;
		_return.Height = _TrophyInfo.Height;
		BYTE SocketColor = 0;
		for(int i=0;i<6;++i)
		{
			switch (_TrophyInfo.Sockets[i])
			{
			case 1:
				++(_return.Socket);
				SocketColor |= 1;
				break;
			case 2:
				++(_return.Socket);
				SocketColor |= 2;
				break;
			case 3:
				++(_return.Socket);
				SocketColor |= 4;
				break;
			}
		}
		if(SocketColor==7)
			_return.ThreeColorSocket = true;
		else
			_return.ThreeColorSocket = false;
		_return.SocketConnect = 0;
		for(int i=0;i<6;++i)
		{
			if (_TrophyInfo.SocketsContact[i]>_return.SocketConnect)
				_return.SocketConnect=_TrophyInfo.SocketsContact[i];
		}
#ifndef NO_DEBUG
		for (int j = 0; j < 64; j += 2)
		{
			if (_TrophyInfo.Name[j] == 0 && _TrophyInfo.Name[j + 1] == 0)
				break;
			_return.Name.push_back(_TrophyInfo.Name[j]);
			_return.Name.push_back(_TrophyInfo.Name[j + 1]);
		}

		for (int j = 0; j < 192; j += 2)
		{
			if (_TrophyInfo.InterfaceName[j] == 0 && _TrophyInfo.InterfaceName[j + 1] == 0)
				break;
			_return.Name.push_back(_TrophyInfo.InterfaceName[j]);
			_return.Name.push_back(_TrophyInfo.InterfaceName[j + 1]);
		}
#endif
	}
	std::map<int, int> LootFilter;//拾取过滤,符合规则的才拾取
	std::set<wstring> MustLootList;//按名称必须拾取的物品
	int nSkillQualityFilter;//技能石过滤品质
	int SocketCountFilter;
	int SocketConnectCountFilter;
	bool bLootThreeSocketColor;
	int32_t SetLootTypeList(const std::vector<LootType> & LootList, const int16_t SocketFilter, const int16_t SocketConnectFilter, const bool LootThreeSocketColor, const int16_t SkillQualityFilter)
	{
		SocketCountFilter = SocketFilter;
		SocketConnectCountFilter = SocketConnectFilter;
		bLootThreeSocketColor = LootThreeSocketColor;
		nSkillQualityFilter=SkillQualityFilter;
		// Your implementation goes here
		//printf("SetLootTypeList\n");
		LootFilter.clear();
		for (auto item : LootList)
		{
			LootFilter.insert(std::make_pair(item.Type, item.Color));
		}
		return 0;
	}
	int32_t ClearTrophyFilter()
	{
	//	SocketCountFilter = 6;
	//	SocketConnectCountFilter = 5;
	//	bLootThreeSocketColor = true;
		// Your implementation goes here
		TrophyFilter.clear();
		return 0;
	}
	void GetTrophyList(std::vector<TrophyInfo> & _return, const std::vector<TrophyBaseInfo> & TrophyIDList)
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetTrophyList\n");
#endif
	//	::OutputDebugString(L"GetTrophyList\n");
		set<Point> NeedLootPos;
		for (auto item : TrophyIDList)
		{
			
			NolootTrophyObjPtr = item.ObjPtr;
			SendMessage(hGameWnd, WM_LG_CALL, F_GetTrophyInfo, NULL);

			int nType = 0;
			
			if (IsCurrencyType(_TrophyInfo.InterfaceName))
			{
				CStringW strName = (wchar_t*)(_TrophyInfo.Name);
				if (strName == L"魉途磔S" || strName == L"知R卷S")
				{
					nType = byTrophy_Currency;
				}
				else
					nType = byTrophy_Money;
			//	nType = byTrophy_Currency;
			}
			else if (IsFlaskType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Flask;
			}
			else if (IsArmourType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Armour;
			}
			else if (IsWeaponType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Weapon;
			}
			else if (IsRingType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Ring;
			}
			else if (IsSkillStoneType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_SkillStone;
			}
			else if (IsAmuletType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Amulet;
			}
			else if (IsQuiverType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Weapon;
			}
			else if (IsBeltType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Belt;
			}
			else if (IsMapsType(_TrophyInfo.InterfaceName))
			{
				nType = byTrophy_Maps;//地图
			}
			else
			{
				nType = UnknowType;
			}
			bool bLoot = false;

			//看看是否是一定拾取的
			wstring strItemName=(wchar_t*)_TrophyInfo.Name;
			auto iterLootName=MustLootList.find(strItemName);
			if (iterLootName != MustLootList.end())
			{
				bLoot = true;
			}


			TrophyInfo temp;
			temp.SocketConnect = 0;
			temp.Socket = 0;
			
			//////////////////////////////////////////////////////////////

			
			if (nType == byTrophy_Weapon || nType == byTrophy_Armour)
			{
				///////////////////////////////////////////////原检测三色装部分,现在只对武器和护甲检测
				int begin = 0;
				for (int i = 0; i<6; ++i)
				{
					if (_TrophyInfo.SocketsContact[i] == 0)
						break;
					if (_TrophyInfo.SocketsContact[i]>temp.SocketConnect)
					{
						temp.SocketConnect = _TrophyInfo.SocketsContact[i];
					}
					if (_TrophyInfo.SocketsContact[i] > 2)//检测三色孔
					{
						int SocketColor = 0;
						for (int j = begin; j < (_TrophyInfo.SocketsContact[i] + begin); ++j)
						{
							switch (_TrophyInfo.Sockets[j])
							{
							case 1:
								SocketColor |= 1;
								break;
							case 2:
								SocketColor |= 2;
								break;
							case 3:
								SocketColor |= 4;
								break;
							}
						}
						if (SocketColor == 7)
							temp.ThreeColorSocket = true;
					}
					begin += _TrophyInfo.SocketsContact[i];
				}
				for (int i = 0; i < 6; ++i)
				{
					switch (_TrophyInfo.Sockets[i])
					{
					case 1:
					case 2:
					case 3:
						++(temp.Socket);
						break;
					}
				}
				///////////////////////////////////////////////////////////////////////////////
				if (SocketCountFilter > 0)
				{
					if (temp.Socket >= SocketCountFilter)
						bLoot = true;
				}
				if (bLoot == false)
				{
					if (SocketConnectCountFilter > 0)
					{
						if (temp.SocketConnect >= SocketConnectCountFilter)
							bLoot = true;
					}
				}
				if (bLoot == false)
				{
					if (temp.ThreeColorSocket && bLootThreeSocketColor)
						bLoot = true;
				}
			}

			if (bLoot == false)
			{
				auto iter = LootFilter.find(nType);
				Point pos(item.X, item.Y);
				if (iter == LootFilter.end())//不在拾取类型列表里,则不拾取
				{
					auto iter = NeedLootPos.find(pos);
					if (iter == NeedLootPos.end())
						TrophyFilter.insert(pos);
					continue;
				}
				//如果是技能石,看下品质,不够的也不要
				if (nType == byTrophy_SkillStone)
				{
					if (_TrophyInfo.Quality<nSkillQualityFilter)
					{
						auto iter = NeedLootPos.find(pos);
						if (iter == NeedLootPos.end())
							TrophyFilter.insert(pos);
						continue;
					}
				}
				if (iter->second > _TrophyInfo.Color)//颜色值大于,也不拾取
				{
				//	Point pos(item.X, item.Y);
					auto iter = NeedLootPos.find(pos);
					if (iter == NeedLootPos.end())
						TrophyFilter.insert(pos);
					continue;
				}
			}
			//如果在的,得删除
			Point pos(item.X, item.Y);
			auto iter=TrophyFilter.find(pos);
			if (iter != TrophyFilter.end())
			{
				TrophyFilter.erase(iter);
			}
			NeedLootPos.insert(pos);
			temp.Type = nType;
			temp.ObjPtr = item.ObjPtr;
			temp.Color = _TrophyInfo.Color;
			temp.ID = _TrophyInfo.ID;
			temp.Width = _TrophyInfo.Width;
			temp.Height = _TrophyInfo.Height;
			temp.X = item.X;
			temp.Y = item.Y;
#ifndef NO_DEBUG
			for (int j = 0; j < 64; j += 2)
			{
				if (_TrophyInfo.Name[j] == 0 && _TrophyInfo.Name[j + 1] == 0)
					break;
				temp.Name.push_back(_TrophyInfo.Name[j]);
				temp.Name.push_back(_TrophyInfo.Name[j + 1]);
			}
#endif
			_return.push_back(temp);
		}

	}

	int32_t ReadLoginState() 
	{
		// Your implementation goes here
	//	printf("ReadLoginState\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_GetLoginStatus, NULL);
		return nLoginStatus;
	}

	int32_t UseItem(const int32_t WinID, const int32_t ServiceID) 
	{
		// Your implementation goes here
		//printf("UseItem\n");
		UseItem_WinID = WinID;
		UseItem_ServiceID = ServiceID;
		SendMessage(hGameWnd, WM_LG_CALL, F_UseItem, NULL);
		return nCallRet;
	}
	int32_t UseTransDoor() 
	{
		ContainerType = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			if (IsTransDoorType(pBag->Items[i].Name))
			{
				UseItem(pBag->WinID,pBag->Items[i].ServiceID);
				return SUCCESS;
			}
		}
		return 1;
	}

	int32_t ClickNPCMenu(const int32_t MenuID) 
	{
		// Your implementation goes here
		//printf("ClickNPCMenu\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_ClickNPCMenu, MenuID);
		return nCallRet;
	}

	int32_t PutToSell(const int32_t Left, const int32_t Top, const int32_t ServiceID, const int32_t WinID) 
	{
		// Your implementation goes here
		//printf("PutToSell\n");
		SellLeft=Left;
		SellTop=Top;
		SellServiceID=ServiceID;
		SellWinID=WinID;
		SendMessage(hGameWnd, WM_LG_CALL, F_PutToSell, NULL);
		return nCallRet;
	}

	int32_t ConfirmSell() 
	{
		// Your implementation goes here
		//printf("ConfirmSell\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_ConfirmSell, NULL);
		return nCallRet;
	}

	int32_t ReturnChoseRole() 
	{
		// Your implementation goes here
		//printf("ReturnChoseRole\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_Logout, NULL);
		return nCallRet;
	}

	int32_t Relive(const int32_t ReliveType) 
	{
		// Your implementation goes here
		SendMessage(hGameWnd, WM_LG_CALL, F_Relive, ReliveType);
		return nCallRet;
		//printf("Relive\n");
	}
	int32_t GetNearbyWaypointID()
	{
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 1000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsWaypoint(pTempRoundList->InterfaceName))
				{
					ret= pTempRoundList->ID;
					break;
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyWaypointPos()
	{
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 1000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsWaypoint(pTempRoundList->InterfaceName))
				{
					ret = pTempRoundList->X2<<16;
					ret |= pTempRoundList->Y2;
					break;
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyWaypointObjPtr()
	{
		// Your implementation goes here
		//printf("GetNearbyWaypointObjPtr\n");
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 1000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsWaypoint(pTempRoundList->InterfaceName))
				{
					ret = pTempRoundList->mem2;
					break;
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbySellNPCObjPtr(const int32_t NPCNum) 
	{
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		CStringW strTargetNPCName;
		switch (NPCNum)
		{
		case 1:
			strTargetNPCName = L"奈莎";
			break;
		case 2:
			strTargetNPCName = L"古斯特";
			break;
		case 3:
			strTargetNPCName = L"R根";
			break;
		case 4:
			strTargetNPCName = L"o甲大哈";
			break;
		case 5:
			strTargetNPCName = L"亡`大卡塔莉娜";
			break;
		case 6:
			strTargetNPCName = L"武器大瓦甘";
			break;
		case 7:
			strTargetNPCName = L"刺⒋瓦里西";
			break;
		case 8:
			strTargetNPCName = L"博W大艾雷恩";
			break;
		case 9:
			strTargetNPCName = L"狩C大托";
			break;
		case 10:
			strTargetNPCName = L"uD大札娜";
			break;
		}
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsNPC(pTempRoundList->InterfaceName))
				{
					CStringW strName = (wchar_t*)pTempRoundList->Name;
					if (strName == strTargetNPCName)
					{
						ret = pTempRoundList->mem2;
						break;
					}
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	
	int64_t GetNearbySellNPCPos()
	{
		// Your implementation goes here
		//printf("GetNearbySellNPCPos\n");
		int64_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			//暂时只保留了怪物
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsNPC(pTempRoundList->InterfaceName))
				{
					wstring strName = (wchar_t*)pTempRoundList->Name;
					auto iter=NPCList.find(strName);
					if (iter != NPCList.end())
					{
						ret = iter->second;
						ret = ret << 32;
						ret |= pTempRoundList->X2 << 16;
						ret |= pTempRoundList->Y2;
						break;
					}
				}
			}
			++pTempRoundList;
		}
		return ret;
	}

	int32_t GetNearbyGoCityTransferDoorObjPtr()
	{
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsGobackTransferDoor(pTempRoundList->InterfaceName))
				{
					ret = pTempRoundList->mem2;
					break;

				}
			}
			++pTempRoundList;
		}
		return ret;
	}

	int32_t GetNearbyGoBattleTransfetDoorObjPtr()
	{
		// Your implementation goes here
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsGobattleTransferDoor(pTempRoundList->InterfaceName))
				{
					CStringW strName = (wchar_t*)pTempRoundList->Name;
					if (strName != L"城魉烷T")
					{
						ret = pTempRoundList->mem2;
						break;
					}
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyStorageObjPtr()
	{
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsStorage(pTempRoundList->InterfaceName))
				{
					ret = pTempRoundList->mem2;
					break;
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyStoragePos()
	{
		// Your implementation goes here
		//printf("GetNearbyStoragePos\n");
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsStorage(pTempRoundList->InterfaceName))
				{
					ret = pTempRoundList->X2 << 16;
					ret |= pTempRoundList->Y2;
					break;
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyCrossObjPtr()
	{
		// Your implementation goes here
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsCrossArea(pTempRoundList->InterfaceName))
				{
					CStringW strName = (wchar_t*)pTempRoundList->Name;
					if (strName == L"翘")
					{
						//ret = pTempRoundList->mem2;
						ret = pTempRoundList->X2 << 16;
						ret |= pTempRoundList->Y2;
						break;
					}
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyPollutantGateObjPtr()
	{
		// Your implementation goes here
		//printf("GetNearbyPollutantGateObjPtr\n");
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsCrossArea(pTempRoundList->InterfaceName))
				{
					wstring strName = (wchar_t*)pTempRoundList->Name;
					auto iter = PollutantGateName.find(strName);
					//if (strName == L"z落地窖")
					if (iter != PollutantGateName.end())
					{
						ret = pTempRoundList->mem2;
						break;
					}
				}
			}
			++pTempRoundList;
		}
		return ret;
	}
	int32_t GetNearbyOutPollutantGatePos()
	{
		// Your implementation goes here
		//printf("GetNearbyOutPollutantGatePos\n");
		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsCrossArea(pTempRoundList->InterfaceName))
				{
					wstring strName = (wchar_t*)pTempRoundList->Name;
					auto iter = PollutantGateName.find(strName);
					//if (strName == L"z落地窖")
					if (iter != PollutantGateName.end())
					{
						ret = pTempRoundList->X2<<16;
						ret |= pTempRoundList->Y2;
						break;
					}
				}
			}
			++pTempRoundList;
		}
		return ret;
		//return 0;
	}

	int32_t ReloadPollutantGateName() 
	{
		//////////////////////////////////////////////////////////////污染地穴门
		PollutantGateName.clear();
		fstream file;
		wstring strPath = szModulePath;
		strPath += L"\\gatename.txt";
		file.open(strPath, ios::in | ios::binary);
		do
		{
			wstring name;
			wchar_t buff[10] = { 0 };

			file.read((char*)buff, 20);
			name = buff;
			if (name.size() > 0)
				PollutantGateName.insert(name);
		} while (!file.eof());
		file.close();
		///////////////////////////////////////////////////////////////////////////////
		//优先攻击怪物
		PriorMonsterName.clear();
		strPath = szModulePath;
		strPath += L"\\MonsterName.txt";
		file.open(strPath, ios::in | ios::binary);
		do
		{
			wstring name;
			wchar_t buff[11] = { 0 };
			file.read((char*)buff, 22);
			name = buff;
			char* p = (char*)buff;
			int nPrior = p[20];
			if (name.size() > 0)
				PriorMonsterName.insert(std::make_pair(name,nPrior));
			//	MessageBox(name.c_str());
		} while (!file.eof());
		file.close();
		///////////////////////////////////////////////名称拾取列表
		MustLootList.clear();
		strPath = szModulePath;
		strPath += L"\\LootName.txt";
		file.open(strPath, ios::in | ios::binary);
		do
		{
			wstring name;
			wchar_t buff[11] = { 0 };
			file.read((char*)buff, 22);
			name = buff;
		
			if (name.size() > 0)
				MustLootList.insert(name);
		} while (!file.eof());
		file.close();

		// Your implementation goes here
	//	printf("ReloadPollutantGateName\n");
		/*PollutantGateName.clear();
		wfstream file;
		wstring strPath = szModulePath;
		strPath += L"\\gatename.txt";
		file.open(strPath, ios::in);
		file.imbue(locale(""));
		do
		{
			wstring name;
			file >> name;
			if (name.size() > 0)
				PollutantGateName.insert(name);
		} while (!file.eof());*/
		return PollutantGateName.size();
	}

	int32_t LogGateName()
	{
		wfstream file;
		wstring strPath = szModulePath;
		strPath += L"\\log.txt";
		file.open(strPath, ios::out);

		file.imbue(locale(""));

		int32_t ret = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetRoundList, NULL);
		RoundObjInfo* pTempRoundList = pRoundList;
		byte type = 0;
		int n = 0;
		for (int i = 0; i < 3000; ++i)
		{
			if (!pTempRoundList->mem2)
				break;
			if (pTempRoundList->Name[0] == 0 && pTempRoundList->Name[1] == 0)
			{
				++pTempRoundList;
				continue;
			}
			else
			{
				if (IsCrossArea(pTempRoundList->InterfaceName))
				{
					wstring strName = (wchar_t*)pTempRoundList->Name;
					file << strName.c_str() << endl;
					++n;
				}
			}
			++pTempRoundList;
		}
		file.close();
		return n;
	}

	int32_t PickupItem(const int32_t BagObjPtr, const int32_t ItemServiceID)
	{
		// Your implementation goes here
		//printf("PickupItem\n");
		PickBagPtr = BagObjPtr;
		PicupServiceID = ItemServiceID;
		SendMessage(hGameWnd, WM_LG_CALL, F_Pickup, NULL);
		return 0;
	}

	int32_t DropdownItem(const int32_t StoragePageObjPtr, const int16_t Left, const int16_t Top) 
	{
		// Your implementation goes here
		//printf("DropdownItem\n");
		nStoragePageObjPtr = StoragePageObjPtr;
		StorageLeft = Left;
		StorageTop = Top;
		SendMessage(hGameWnd, WM_LG_CALL, F_DropDown, NULL);
		return 0;
	}
	int32_t DropdownItemStack(const int32_t StoragePageObjPtr, const int32_t TargetServiceID) 
	{
		// Your implementation goes here
		//printf("DropdownItemStack\n");
		nStoragePageObjPtr = StoragePageObjPtr;
		TargetStackServiceID = TargetServiceID;
		SendMessage(hGameWnd, WM_LG_CALL, F_DropDownStack, NULL);
		return 0;
	}

	int32_t ActiveStoragePageInfo(const int32_t PageNum)
	{
		// Your implementation goes here
		//printf("ActiveStoragePageInfo\n");
		StoragePageNum = PageNum;
		SendMessage(hGameWnd, WM_LG_CALL, F_ActiveStoragePage, NULL);
		return 0;
	}

	int32_t GetStoragePagePtr(const int32_t ContainerNum)
	{
		ContainerType = ContainerNum;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		return pBag->Mem;
	}
	int32_t IdentityItem(const int32_t CurrencyServiceID, const int32_t ArmorServiceID)
	{
		// Your implementation goes here
		//printf("IdentityItem\n");
		IdentityCurrencyServiceID = CurrencyServiceID;
		IdentityItemServiceID = ArmorServiceID;
		SendMessage(hGameWnd, WM_LG_CALL, F_IdentityItem, NULL);
		return 0;
	}
	void WaitCastComplete()
	{
		for (int i = 0; i < 35; ++i)
		{
			// Your implementation goes hereSendMessage(hGameWnd, WM_LG_CALL, F_GetPlayerInfo, NULL);
			SendMessage(hGameWnd, WM_LG_CALL, F_GetPlayerInfo, NULL);
			if (_PlayerInfo.ActorCode != 0x2 && _PlayerInfo.ActorCode != 0x12&&_PlayerInfo.ActorCode != 0x80)
				return;
			else
				Sleep(30);
		}
	}

	int32_t ReadStorageUIPTR(const int32_t PageNum) 
	{
		// Your implementation goes here
		SendMessage(hGameWnd, WM_LG_CALL, F_ReadStorageUI, PageNum);
		return StroagePageNZNum;
	}
	int32_t ReadStoragePageNum()
	{
		// Your implementation goes here
	//	printf("ReadStoragePageNum\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_ReadStoragePageNum, NULL);
		return StoragePageCount;
	}

	void HitKey(const int32_t Key)
	{
		// Your implementation goes here

	//	MessageBox(NULL, L"222", NULL, MB_OK);
		//HWND hGameWnd = ::FindWindow(L"Direct3DWindowClass", NULL);
		if (hGameWnd == NULL)
		{
			hGameWnd = ::FindWindow(L"Direct3DWindowClass", NULL);
			if (hGameWnd == NULL)
			{
				MessageBox(NULL, L"窗口未初始化,无法发送按键消息", NULL, MB_OK);
				return;
			}
		}
		OutputDebugString(L"HitKey\n");
	//	MessageBox(NULL, L"1111", NULL, MB_OK);
		switch (Key)
		{
		case 1:
			PostMessage(hGameWnd, WM_KEYDOWN, 0x31, 0x20001);
			PostMessage(hGameWnd, WM_CHAR, 0x31, 0x20001);
			PostMessage(hGameWnd, WM_KEYUP, 0x31, 0xC0020001);
			break;
		case 2:
			PostMessage(hGameWnd, WM_KEYDOWN, 0x32, 0x30001);
			PostMessage(hGameWnd, WM_CHAR, 0x32, 0x30001);
			PostMessage(hGameWnd, WM_KEYUP, 0x32, 0xC0030001);
			break;
		case 3:
			PostMessage(hGameWnd, WM_KEYDOWN, 0x33, 0x40001);
			PostMessage(hGameWnd, WM_CHAR, 0x33, 0x40001);
			PostMessage(hGameWnd, WM_KEYUP, 0x33, 0xC0040001);
			break;
		case 4:
			PostMessage(hGameWnd, WM_KEYDOWN, 0x34, 0x50001);
			PostMessage(hGameWnd, WM_CHAR, 0x34, 0x50001);
			PostMessage(hGameWnd, WM_KEYUP, 0x34, 0xC0050001);
			break;
		case 5:
			PostMessage(hGameWnd, WM_KEYDOWN, 0x35, 0x60001);
			PostMessage(hGameWnd, WM_CHAR, 0x35, 0x60001);
			PostMessage(hGameWnd, WM_KEYUP, 0x35, 0xC0060001);
			break;

		case 6:
			PostMessage(hGameWnd, WM_KEYDOWN, 0xD, 0x1C0001);
			PostMessage(hGameWnd, WM_CHAR, 0xD, 0x1C0001);
			PostMessage(hGameWnd, WM_KEYUP, 0x1C, 0xC01C0001);
			break;
		case 7:
			PostMessage(hGameWnd, WM_KEYDOWN, 0x1B, 0x10001);
			PostMessage(hGameWnd, WM_CHAR, 0x1B, 0x10001);
			PostMessage(hGameWnd, WM_KEYUP, 0x1B, 0xC0010001);
			break;
		}
	}
	void UpSkill() 
	{
		// Your implementation goes here
		//printf("UpSkill\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_UpSkill, NULL);
	}


	bool IsItemOnMouse()
	{
		// Your implementation goes here
	//	printf("IsItemOnMouse\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_ItemOnMouse, NULL);
		if (nItemOnMouse == 1)
			return true;
		return false;
	}

	bool IsBuffExists(const int32_t skill) 
	{
		// Your implementation goes here
		//printf("IsBuffExists\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_BuffExist, skill);
		if (nBuffExist == 1)
			return true;
		return false;
	}

	int32_t GetItemDescription(const int32_t ItemObjPtr)
	{
		// Your implementation goes here
	//	printf("GetItemDescription\n");
		SendMessage(hGameWnd, WM_LG_CALL, F_GetItemDescrib, ItemObjPtr);
		return 0;
	}

	void GetBagItemFullInfo(std::vector<ItemFullInfo> & _return) 
	{
#ifndef NO_DEBUG
		::OutputDebugString(L"GetBagItemFullInfo\n");
#endif
		// Your implementation goes here
		ContainerType = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			GetItemDescription(pBag->Items[i].ObjPtr);
		}
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			ItemFullInfo temp;
			temp.WinID = pBag->WinID;
			temp.BagObjPtr = pBag->Mem;////////////这里要注意
			temp.ObjPtr = pBag->Items[i].ObjPtr;
			temp.ID = pBag->Items[i].ID;
			temp.Color = pBag->Items[i].Color;
			temp.Count = pBag->Items[i].Count;
			temp.MaxCount = pBag->Items[i].MaxCount;
			temp.ServiceID = pBag->Items[i].ServiceID;
			temp.Left = pBag->Items[i].Left;
			temp.Top = pBag->Items[i].Top;
			temp.Width = pBag->Items[i].Width;
			temp.Height = pBag->Items[i].Height;
			temp.Quality = pBag->Items[i].Quality;
			if (pBag->Items[i].IsEquipment == 1 && pBag->Items[i].IsIdentity == 0)
				temp.NeedIdentify = true;
			else
				temp.NeedIdentify = false;

			temp.SocketConnect = 0;
			temp.Socket = 0;
			int begin = 0;
			for (int d = 0; d<6; ++d)
			{
				if (pBag->Items[i].SocketsContact[d] == 0)
					break;
				if (pBag->Items[i].SocketsContact[d]>temp.SocketConnect)
				{
					temp.SocketConnect = pBag->Items[i].SocketsContact[d];
				}
				if (pBag->Items[i].SocketsContact[d] > 2)//检测三色孔
				{
					int SocketColor = 0;
					for (int j = begin; j < (pBag->Items[i].SocketsContact[d] + begin); ++j)
					{
						switch (pBag->Items[i].Sockets[j])
						{
						case 1:
							SocketColor |= 1;
							break;
						case 2:
							SocketColor |= 2;
							break;
						case 3:
							SocketColor |= 4;
							break;
						}
					}
					if (SocketColor == 7)
						temp.ThreeColorSocket = true;
				}
				begin += pBag->Items[i].SocketsContact[d];
			}
			for (int j = 0; j < 6; ++j)
			{
				switch (pBag->Items[i].Sockets[j])
				{
				case 1:
				case 2:
				case 3:
					++(temp.Socket);
					break;
				}
			}

			if (IsSkillStoneType(pBag->Items[i].InterfaceName))//1
			{
				temp.Type = byTrophy_SkillStone;
			}
			else if (IsCurrencyType(pBag->Items[i].InterfaceName))//2
			{
				CStringW strName = (wchar_t*)(pBag->Items[i].Name);
				if (strName == L"魉途磔S" || strName == L"知R卷S")
				{
					temp.Type = byTrophy_Currency;
				}
				else
					temp.Type = byTrophy_Money;
			}
			else if (IsFlaskType(pBag->Items[i].InterfaceName))//3
			{
				temp.Type = byTrophy_Flask;
			}
			else if (IsArmourType(pBag->Items[i].InterfaceName))//4
			{
				temp.Type = byTrophy_Armour;
			}
			else if (IsRingType(pBag->Items[i].InterfaceName))//5
			{
				temp.Type = byTrophy_Ring;
			}
			else if (IsAmuletType(pBag->Items[i].InterfaceName))//6
			{
				temp.Type = byTrophy_Amulet;
			}
			else if (IsWeaponType(pBag->Items[i].InterfaceName))//7
			{
				temp.Type = byTrophy_Weapon;
			}
			else if (IsQuestItemType(pBag->Items[i].InterfaceName))//8
			{
				temp.Type = byTrophy_QuestItem;
			}
			else if (IsBeltType(pBag->Items[i].InterfaceName))//9
			{
				temp.Type = byTrophy_Belt;
			}
			else if (IsQuiverType(pBag->Items[i].InterfaceName))//10
			{
				temp.Type = byTrophy_Weapon;//箭包暂时算武器
			}
			else if (IsMapsType(pBag->Items[i].InterfaceName))
			{
				temp.Type = byTrophy_Maps;//地图
			}
			else
				temp.Type = UnknowType;

			for (int j = 0; j < 64; j += 2)
			{
				if (pBag->Items[i].Name[j] == 0 && pBag->Items[i].Name[j + 1] == 0)
					break;
				temp.Name.push_back(pBag->Items[i].Name[j]);
				temp.Name.push_back(pBag->Items[i].Name[j + 1]);
			}
#ifndef NO_DEBUG
			for (int j = 0; j < 192; j += 2)
			{
				if (pBag->Items[i].InterfaceName[j] == 0 && pBag->Items[i].InterfaceName[j + 1] == 0)
					break;
				temp.TypeName.push_back(pBag->Items[i].InterfaceName[j]);
				temp.TypeName.push_back(pBag->Items[i].InterfaceName[j + 1]);
			}
#endif		
			for (int k = 0; k < 14; ++k)
			{
				for (int j = 0; j < 32; j += 2)
				{
					if (pBag->Items[i].StatDescriptions[k][j] == 0 && pBag->Items[i].StatDescriptions[k][j + 1] == 0)
						break;
					temp.DescribInfo.push_back(pBag->Items[i].StatDescriptions[k][j]);
					temp.DescribInfo.push_back(pBag->Items[i].StatDescriptions[k][j + 1]);
				}
				temp.DescribInfo.push_back(124);
				temp.DescribInfo.push_back(0);
			//	temp.DescribInfo.push_back()
			}
			_return.push_back(temp);
		}
	}
	void GetBagItemPropertyInfo(std::vector<ItemPropertyInfo> & _return) 
	{
		// Your implementation goes here
		//printf("GetBagItemPropertyInfo\n");
#ifndef NO_DEBUG
		::OutputDebugString(L"GetBagItemPropertyInfo\n");
#endif
		// Your implementation goes here
		ContainerType = 0;
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			GetItemDescription(pBag->Items[i].ObjPtr);
		}
		SendMessage(hGameWnd, WM_LG_CALL, F_GetBagItemList, NULL);
		for (int i = 0; i < dwBagItemCount; ++i)
		{
			ItemPropertyInfo temp;
			for (int j = 0; j < 64; j += 2)
			{
				if (pBag->Items[i].Name[j] == 0 && pBag->Items[i].Name[j + 1] == 0)
					break;
				temp.Name.push_back(pBag->Items[i].Name[j]);
				temp.Name.push_back(pBag->Items[i].Name[j + 1]);
			}	
			for (int k = 0; k < 14; ++k)
			{
				for (int j = 0; j < 32; j += 2)
				{
					if (pBag->Items[i].StatDescriptions[k][j] == 0 && pBag->Items[i].StatDescriptions[k][j + 1] == 0)
						break;
					temp.Property.push_back(pBag->Items[i].StatDescriptions[k][j]);
					temp.Property.push_back(pBag->Items[i].StatDescriptions[k][j + 1]);
				}
				temp.Property.push_back(124);
				temp.Property.push_back(0);
			}
			_return.push_back(temp);
		}
	}
	int32_t TransHideHome()
	{
		// Your implementation goes here
		//printf("TransHideHome\n");
		int nServiceID = 0;
		nServiceID=ReadHideoutServiceID();
		if (nServiceID == 0)
			return 1;
		SendMessage(hGameWnd, WM_LG_CALL, F_TransHideHome, nServiceID);
		return 0;
	}

	void GetNPCMenuInfo(std::vector<NPCMenuInfo> & _return)
	{
		// Your implementation goes here 
		//printf("GetNPCMenuInfo\n");
		memset(NPCMenuList, 0, sizeof(NPCMenuItem)* 20);
		SendMessage(hGameWnd, WM_LG_CALL, F_GetNPCMenuInfo, NULL);		
		for (int i = 0; i < 20; ++i)
		{
			NPCMenuInfo temp;
			temp.ID=NPCMenuList[i].ID;
			
			for (int j = 0; j < 32; j += 2)
			{

				if (NPCMenuList[i].Text[j] == 0 && NPCMenuList[i].Text[j + 1] == 0)
					break;
				temp.Text.push_back(NPCMenuList[i].Text[j]);
				temp.Text.push_back(NPCMenuList[i].Text[j+1]);
			}
			if (temp.ID == 0&&temp.Text.size()<1)
				break;
			_return.push_back(temp);
		}
		return;
	}
	int32_t ClickNPCSellMenu() 
	{
		// Your implementation goes here
	//	printf("ClickNPCSellMenu\n");
		memset(NPCMenuList, 0, sizeof(NPCMenuItem)* 20);
		SendMessage(hGameWnd, WM_LG_CALL, F_GetNPCMenuInfo, NULL);
		int nID = -1;
		for (int i = 0; i < 20; ++i)
		{
			wstring text =(wchar_t*) NPCMenuList[i].Text;
			if (text == _T("u物品"))
			{
				nID = NPCMenuList[i].ID;
				break;
			}
		}
		if (nID == -1)
		{
			return 1;
		}
		else
		{
			SendMessage(hGameWnd, WM_LG_CALL, F_ClickNPCMenu, nID);
			return 0;
		}
	}
	int32_t LeftClickItem(const int32_t BagObjPtr, const int32_t ItemServiceID) 
	{
		// Your implementation goes here
		PickBagPtr = BagObjPtr;
		PicupServiceID = ItemServiceID;
		SendMessage(hGameWnd, WM_LG_CALL, F_LeftClickItem, NULL);
		return 0;
	}
	int32_t SaveToStorage(const int32_t StoragePageNum, const int32_t ItemServiceID) 
	{
		// Your implementation goes here
	//	printf("SaveToStorage\n");
		PicupServiceID = ItemServiceID;
		SendMessage(hGameWnd, WM_LG_CALL, F_SaveToStorage, StoragePageNum);
		return 0;
	}
};


unsigned int WINAPI ServerThread(LPVOID) 
{
 /* int port = 9090;
  shared_ptr<GameFuncCallHandler> handler(new GameFuncCallHandler());
  shared_ptr<TProcessor> processor(new GameFuncCallProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

  hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, EVENT_STRING);
  if (hEvent != NULL)
	  SetEvent(hEvent);
  server.serve();*/
  //////////////////////////////////////////////////////////////////////////////////

	boost::shared_ptr<GameFuncCallHandler> handler(new GameFuncCallHandler());
	boost::shared_ptr<TProcessor> processor(new GameFuncCallProcessor(handler));

  boost::shared_ptr<TServerTransport> serverTransport(new TPipeServer("xsxsxs"));
 // boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(9998));

  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  size_t workers = 4;
  boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workers);
  boost::shared_ptr<PlatformThreadFactory> threadFactory = boost::shared_ptr<PlatformThreadFactory>(new PlatformThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);

  hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, EVENT_STRING);
  if (hEvent != NULL)
	  SetEvent(hEvent);
  server.serve();
  return 0;
}

